/**

SpagoBI - The Business Intelligence Free Platform

Copyright (C) 2005 Engineering Ingegneria Informatica S.p.A.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

**/
package it.eng.spagobi.qbe.tree.presentation.tag;

import it.eng.qbe.datasource.BasicHibernateDataSource;
import it.eng.qbe.datasource.CompositeHibernateDataSource;
import it.eng.qbe.javascript.QbeJsTreeNodeId;
import it.eng.qbe.log.Logger;
import it.eng.qbe.model.DataMartModel;
import it.eng.qbe.model.IDataMartModel;
import it.eng.qbe.query.ISelectField;
import it.eng.qbe.urlgenerator.IURLGenerator;
import it.eng.qbe.urlgenerator.SelectFieldForSelectionURLGenerator;
import it.eng.qbe.utility.CalculatedField;
import it.eng.qbe.utility.JsTreeUtils;
import it.eng.qbe.utility.QbeProperties;
import it.eng.qbe.utility.RelationField;
import it.eng.qbe.wizard.EntityClass;
import it.eng.qbe.wizard.ISingleDataMartWizardObject;
import it.eng.spago.base.ApplicationContainer;
import it.eng.spago.configuration.ConfigSingleton;
import it.eng.spagobi.qbe.commons.urlgenerator.IQbeTreeUrlGenerator;
import it.eng.spagobi.qbe.commons.urlgenerator.IQbeUrlGenerator;
import it.eng.spagobi.qbe.commons.urlgenerator.PortletQbeUrlGenerator;
import it.eng.spagobi.qbe.commons.urlgenerator.WebQbeUrlGenerator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;

import org.hibernate.SessionFactory;
import org.hibernate.impl.SessionFactoryImpl;
import org.hibernate.mapping.Column;
import org.hibernate.mapping.PersistentClass;
import org.hibernate.mapping.Property;
import org.hibernate.metadata.ClassMetadata;
import org.hibernate.type.CollectionType;
import org.hibernate.type.ComponentType;
import org.hibernate.type.ManyToOneType;
import org.hibernate.type.Type;

/**
 * @author Andrea Gioia (andrea.gioia@eng.it)
 *
 */
public class QbeTreeBuilder  {
	
	private Class qbeTreeClass;
	private IQbeTreeUrlGenerator urlGenerator;	
	
	private IDataMartModel datamartModel;	
	QbeProperties qbeProperties;
	
	String modality = DEFAULT_MODALITY;	
	public static final String FULL_MODALITY = "FULL";
	public static final String LIGHT_MODALITY = "LIGHT";
	public static final String DEFAULT_MODALITY = FULL_MODALITY;
	
	private String classPrefix = null;	
	
	
	
	
	
	public QbeTreeBuilder(String className, IQbeTreeUrlGenerator urlGenerator) throws ClassNotFoundException {		
		setQbeTreeClass( Class.forName(className) );	
		setUrlGenerator(urlGenerator);
	}	
	
		
	public List getQbeTrees(IDataMartModel datamartModel) throws InstantiationException, IllegalAccessException {			
		setDatamartModel(datamartModel);
		qbeProperties = new QbeProperties(datamartModel);				
		return buildQbeTreeList();
	}

	private List buildQbeTreeList() throws InstantiationException, IllegalAccessException {	
		List list = new ArrayList();
		
		List dmNames = datamartModel.getDataSource().getDatamartNames();
		for(int i = 0; i < dmNames.size(); i++) {
			String dmName = (String)dmNames.get(i);
			if(getClassNames( dmName ).size() > 0) {
				IQbeTree tree = buildQbeTree(dmName);
				list.add(tree);
			}
		}	
		
		/*
		targetDatamartName = "Views";
		name = baseName + "_" + dmNames.size();
		if(getHibernateSession() != null && getClassNames().size() > 0) {
			String treeScript = buildQbeTree();
			treeScripts.put(targetDatamartName, treeScript);
		}	
		*/	
		
		
		return list;
	}
	
	
	
	// ABSTRACT -> because of entities' filtering
	// TODO create a filter class instead
	public Map getSelectdNodes(String datamartName) {
		Map map = new HashMap();
		
		for (Iterator it = getClassNames(datamartName).iterator(); it.hasNext(); ){
			String className = (String)it.next();
			map.put(className, className);
		}
		
		return map;
	}
	
	protected Collection getClassNames(String datamartName) {		
		SessionFactory sf = null;
		if(datamartModel.getDataSource() instanceof CompositeHibernateDataSource) {
			sf = ((CompositeHibernateDataSource)datamartModel.getDataSource()).getSessionFactory(datamartName);
		} else {
			sf = datamartModel.getDataSource().getSessionFactory();
		}
		
		Set namesSet = sf.getAllClassMetadata().keySet();
		QbeTreeFields fields = new QbeTreeFields();
		fields.addAllFields(namesSet);
		List namesList = fields.getFieldsOrderedByLabel();
		return namesList;
	}
	
	
	
	
	private IQbeTree buildQbeTree(String datamartName) throws InstantiationException, IllegalAccessException {			
		IQbeTree tree = (IQbeTree)qbeTreeClass.newInstance();
		
		tree.setClassPrefix( getClassPrefix() );
		tree.createTree(datamartName);		
		addRootNode(tree, datamartName);
		int nodeCounter = 0;
		Map selectedNodes = getSelectdNodes(datamartName);
		for (Iterator it = getClassNames(datamartName).iterator(); it.hasNext(); ){
			String className = (String)it.next();
			if(selectedNodes.containsKey(className)) {
				getUrlGenerator().setClassName(className);
				nodeCounter = addEntityNode(tree, className, 
											null, 
											0, /* rootNode */
											nodeCounter,
											null, 1);
			}
		}	
		
		return tree;
	}
	
	
	/**
	 * @param tree
	 * @param rootNodeName
	 */
	public void addRootNode(IQbeTree tree, String rootNodeName) {

		tree.addNode("0", "-1", rootNodeName, "", "", rootNodeName, 
				getUrlGenerator().getResourceUrl("../img/base.gif"),
				getUrlGenerator().getResourceUrl("../img/base.gif"),
				"", "", "", "", "");
	}
	
	public int addEntityNode(IQbeTree tree, 
			String className, 
			String relationOnColumnName, 
			int rootNodeId, int nodeCounter, 
			String prefix, 
			int recursionLevel) {

		String newClassName = className;
		if (relationOnColumnName != null){
			newClassName = className+"("+relationOnColumnName+")";
		}		
		
		if(!qbeProperties.isTableVisible(newClassName)) return nodeCounter;
		if(!datamartModel.getDataMartModelAccessModality().isEntityAccessible(newClassName)) return nodeCounter;
		
		int entityNodeId;
		List subEntities = new ArrayList();
		entityNodeId = addEntityRootNode(tree, className, relationOnColumnName, rootNodeId, nodeCounter);		
		nodeCounter = addKeyFieldNodes(tree, prefix, className, entityNodeId, entityNodeId + 1);
		nodeCounter = addFieldNodes(tree, prefix, className, entityNodeId, nodeCounter, subEntities);
		nodeCounter = addCalculatedFieldNodes(tree, prefix, className, entityNodeId, nodeCounter);
		nodeCounter = addSubEntitiesNodes(tree, className, entityNodeId, nodeCounter, recursionLevel, subEntities);
		
		return nodeCounter;
	
	}
		
	
	/**
	 * 
	 * @param tree
	 * @param className
	 * @param relationOnColumnName
	 * @param rootNodeId
	 * @param nodeCounter
	 * @return
	 */
	public int addEntityRootNode(IQbeTree tree,
							  String className, String relationOnColumnName,
							  int rootNodeId, int nodeCounter) {
		
		String newClassName = className;
		PersistentClass classMapping = datamartModel.getDataSource().getConfiguration().getClassMapping(className);
		
		
		String classLabel = JsTreeUtils.getLabelForClass(datamartModel, className);
		
		if (relationOnColumnName != null){
			
			String labelForRelation = JsTreeUtils.getLabelForForeignKey(datamartModel,className+"("+relationOnColumnName+")");
			if (labelForRelation != null){
				classLabel = labelForRelation;
			}else{
				classLabel += "("+ relationOnColumnName +")";
			}
		}
		
		String classImage;
		if(qbeProperties.getTableType(newClassName) == QbeProperties.CLASS_TYPE_TABLE) {
			classImage = "../img/Class.gif";
		} else if(qbeProperties.getTableType(newClassName) == QbeProperties.CLASS_TYPE_VIEW) {
			classImage = "../img/view.gif";
		} else {
			classImage = "../img/relationship.gif";
		}		
		
		// add class node
		nodeCounter++;
		tree.addNode("" + nodeCounter, "" + rootNodeId, classLabel, "", "", classLabel, 
				getUrlGenerator().getResourceUrl(classImage),
				getUrlGenerator().getResourceUrl(classImage),
				"", "", "", "", "");
		
		return nodeCounter;
	}
	
	/**
	 * 
	 * @param tree
	 * @param prefix
	 * @param className
	 * @param parentEntityNodeId
	 * @param nodeCounter
	 * @return
	 */
	public int addKeyFieldNodes(IQbeTree tree,
								 String prefix, String className,
								 int parentEntityNodeId, int nodeCounter) {
		
				
		PersistentClass classMapping;
		SessionFactory sessionFactory;
		ClassMetadata classMetadata;
		Type identifierType;
				
		classMapping = datamartModel.getDataSource().getConfiguration().getClassMapping(className);
		sessionFactory = datamartModel.getDataSource().getSessionFactory();
		classMetadata = sessionFactory.getClassMetadata(className);
		identifierType = classMetadata.getIdentifierType();
				
			
		String completeFieldName = "";
		String fieldAction = "";
		
		List identifierPropertyNames = new ArrayList();
		String[] propertyClass = null;
		String[] type  = null;
		String[] scale  = null;
		String[] precision = null;
			
		String identifierPropertyName = classMetadata.getIdentifierPropertyName();
			
		if ( identifierType.isComponentType() ) {
					
			ComponentType componentIdentifierType = (ComponentType)identifierType;			
			String[] subPropertyNames = componentIdentifierType.getPropertyNames();					
			Type[] subPropertyTypes = componentIdentifierType.getSubtypes();
			
			
			propertyClass = new String[subPropertyNames.length];
			type  = new String[subPropertyNames.length];
			scale  = new String[subPropertyNames.length];
			precision = new String[subPropertyNames.length];
			Class subPropertyClass = null;
					
			for (int j=0; j < subPropertyNames.length; j++) {
				subPropertyClass = subPropertyTypes[j].getClass();
				identifierPropertyNames.add(identifierPropertyName + "." + subPropertyNames[j]);
				propertyClass[j] = subPropertyClass.getName();
				type[j] = subPropertyTypes[j].getName();
				
			}					
		
		} else {
			propertyClass = new String[1];
			type = new String[1];
			scale = new String[1];
			precision = new String[1];	
			
			identifierPropertyNames.add(identifierPropertyName);
			propertyClass[0] = identifierType.getClass().getName();
			type[0] = identifierType.getName();							
		}
			
		// set scale and precision
		Iterator columnIerator = classMapping.getIdentifierProperty().getColumnIterator();
		for(int k = 0; columnIerator.hasNext(); k++) {
			Column column = (Column)columnIerator.next();
			scale[k] = String.valueOf(column.getScale());
			precision[k] = String.valueOf(column.getPrecision());
		}
		
			    	
	
		for (int j = 0; j < identifierPropertyNames.size(); j++) {

			nodeCounter++;
			completeFieldName = (String)identifierPropertyNames.get(j);

				
			if (prefix != null) {
				completeFieldName = prefix + "." + (String)identifierPropertyNames.get(j);
			}
		
			// unique name of the field for label resolving procedure
			String cn = getUrlGenerator().getClassName();
			cn = (cn.lastIndexOf('.') > 0 ?
				  cn.substring(cn.lastIndexOf('.') + 1 , cn.length()) :
				  cn);
						
			String completeFieldRef = cn + "." + completeFieldName;
				
			String fldLabel = JsTreeUtils.getLabelForField(datamartModel, completeFieldRef);
			if(fldLabel.equalsIgnoreCase(completeFieldRef)) {
				fldLabel = JsTreeUtils.getLabelForField(datamartModel, (String)identifierPropertyNames.get(j));
			}
				
			String addParameters = "";
			addParameters = "";
			addParameters += type[j];
			addParameters += ";"+scale[j];
			addParameters += ";"+precision[j];
			fieldAction = getUrlGenerator().getActionUrlForSelecteField(completeFieldName, fldLabel,  addParameters);
					
					
			String fieldImage;
			int fieldType = qbeProperties.getFieldType(completeFieldRef);
			if(fieldType == QbeProperties.FIELD_TYPE_UNDEFINED) {
				fieldType = qbeProperties.getFieldType((String)identifierPropertyNames.get(j));
				if(fieldType == QbeProperties.FIELD_TYPE_UNDEFINED) {
					fieldType = QbeProperties.FIELD_TYPE_DIMENSION;
				} else {
					qbeProperties.setFieldType(completeFieldRef, fieldType);
				}
			}
					
			if(fieldType == QbeProperties.FIELD_TYPE_DIMENSION) {
				fieldImage = "../img/key.gif";
			} else if(fieldType == QbeProperties.FIELD_TYPE_DIMENSION) {
				fieldImage = "../img/key.gif";
			} else if(fieldType == QbeProperties.FIELD_TYPE_GEOREF) {
				fieldImage = "../img/world.gif";
			} else {
				fieldImage = "../img/key.gif";
			}
					
					
			tree.addNode("" + nodeCounter, "" + parentEntityNodeId, 
								fldLabel,
								fieldAction,  
								fldLabel, 
								"_self",
								getUrlGenerator().getResourceUrl(fieldImage),
								getUrlGenerator().getResourceUrl(fieldImage),
								"", "", "", "", "");	
		}
		
		return nodeCounter;
		
	}
	
	/**
	 * 
	 * @param tree
	 * @param prefix
	 * @param className
	 * @param parentEntityNodeId
	 * @param nodeCounter
	 * @return
	 */
	public int addFieldNodes(IQbeTree tree, 
							   String prefix, String className,
							   int parentEntityNodeId, int nodeCounter, 
							   List subEntities) {
		
		
		PersistentClass classMapping;
		SessionFactory sessionFactory;
		ClassMetadata classMetadata;
		String[] propertyNames;
		Property property;
		String propertyName;
		Type propertyType;
		String fieldAction;
		
		classMapping = datamartModel.getDataSource().getConfiguration().getClassMapping(className);
		sessionFactory = datamartModel.getDataSource().getSessionFactory();		
		classMetadata = sessionFactory.getClassMetadata(className);		
		propertyNames = classMetadata.getPropertyNames();
				
		
		for(int i=0; i < propertyNames.length; i++){
		 	property = classMapping.getProperty(propertyNames[i]);
		 	
		 	// TEST if they are the same: if so use the first invocation
		 	propertyType = property.getType();
		 	propertyType = (Type)classMetadata.getPropertyType(propertyNames[i]);
		 	
		 	Iterator columnIterator = property.getColumnIterator();
		 	Column column;
		 	
		 	if (propertyType instanceof ManyToOneType){
		 		
		 		ManyToOneType manyToOnePropertyType = (ManyToOneType)propertyType; 
		 		String associatedClassName = manyToOnePropertyType.getAssociatedEntityName();
		 		
			 	String columnName = null;
			 	if (columnIterator.hasNext()){
			 		column = (Column)columnIterator.next();
			 		columnName = column.getName(); // ????
			 	}
			 	
		 		propertyName = propertyNames[i];
		 		
		 		if (prefix != null){
		 			 propertyName = prefix +"." + propertyNames[i];
		 		}
		 		
		 		RelationField relationField = 
		 			new RelationField( propertyName, associatedClassName, columnName ); 
		 		
		 		subEntities.add(relationField);	
		 		
		 	} else if (propertyType instanceof CollectionType) {
		 		
		 		
		 		
			} else {
					if(!qbeProperties.isFieldVisible(propertyNames[i])) continue;
					if(!datamartModel.getDataMartModelAccessModality().isFieldAccessible(className, propertyNames[i])) continue;
					
					nodeCounter++;
					
					propertyName = propertyNames[i];					
					String type = propertyType.getName();
					String scale = "";
					String precision = "";
					
									
				 	if (columnIterator.hasNext()){
				 		column = (Column)columnIterator.next();
				 		scale = String.valueOf(column.getScale());
				 		precision = String.valueOf(column.getPrecision());
				 	}
		 		
					if (prefix != null){
						propertyName = prefix +"." + propertyNames[i];
					}
					
					
					 // unique name of the field for label resolving procedure
					String cn = getUrlGenerator().getClassName();
					cn = (cn.lastIndexOf('.') > 0 ?
						  cn.substring(cn.lastIndexOf('.') + 1 , cn.length()) :
						  cn);
							
					String completeFieldRef = cn + "." + propertyName;
				
					String fldLabel = JsTreeUtils.getLabelForField(datamartModel, completeFieldRef);
					if(fldLabel.equalsIgnoreCase(completeFieldRef)) {
						fldLabel = JsTreeUtils.getLabelForField(datamartModel, propertyNames[i]);
					}
					
					String fieldImage;
					int fieldType = qbeProperties.getFieldType(completeFieldRef);
					if(fieldType == QbeProperties.FIELD_TYPE_UNDEFINED) {
						fieldType = qbeProperties.getFieldType(propertyNames[i]);
						if(fieldType == QbeProperties.FIELD_TYPE_UNDEFINED) {
							fieldType = QbeProperties.FIELD_TYPE_DIMENSION;
						} else {
							qbeProperties.setFieldType(completeFieldRef, fieldType);
						}
					}
					
					if(fieldType == QbeProperties.FIELD_TYPE_DIMENSION) {
						fieldImage = "../img/redbox.gif"; //"../img/Method.gif";
					} else if(fieldType == QbeProperties.FIELD_TYPE_MEASURE) {
						fieldImage = "../img/Method.gif"; //"../img/dot.png";
					} else if(fieldType == QbeProperties.FIELD_TYPE_GEOREF) {
						fieldImage = "../img/world.gif"; //"../img/dot.png";
					} else {
						fieldImage = "../img/undef.gif"; //"../img/Method.gif";
					}
					
					
					String addParameters = "";
					addParameters += propertyType.getName();
					addParameters += ";"+scale;
					addParameters += ";"+precision;
					fieldAction = getUrlGenerator().getActionUrlForSelecteField(propertyName, fldLabel,  addParameters);
					
					tree.addNode("" + nodeCounter, "" + parentEntityNodeId, 
			 				fldLabel,
							fieldAction,  
							fldLabel, 
							"_self",
							getUrlGenerator().getResourceUrl(fieldImage),
							getUrlGenerator().getResourceUrl(fieldImage),
							"", "", "",  "", "");
				
				}
		 	}
		
		return nodeCounter;
	}
	
	/**
	 * Add Calculate Fields on the entity
 	 * Control recursion level because calculate field are applied only at etity level not in dimension level
 	 * 
	 * @param tree
	 * @param prefix
	 * @param className
	 * @param parentEntityNodeId
	 * @param nodeCounter
	 * @return
	 */
	public int addCalculatedFieldNodes(IQbeTree tree, 
			   						   String prefix, String className,
			   						   int parentEntityNodeId, int nodeCounter) {
			
		List manualCalcultatedFieldForEntity = 
			datamartModel.getDataSource().getFormula().getManualCalculatedFieldsForEntity(className);
			
		CalculatedField calculatedField = null;
		String fieldAction = null;
		
		Iterator manualCalculatedFieldsIterator = manualCalcultatedFieldForEntity.iterator();
		while (manualCalculatedFieldsIterator.hasNext()){
			calculatedField = (CalculatedField)manualCalculatedFieldsIterator.next();
			
			if (prefix != null){
				calculatedField.setFldCompleteNameInQuery(prefix + "." + calculatedField.getId());
			}else{
				calculatedField.setFldCompleteNameInQuery(calculatedField.getId());
			}
			
			fieldAction = getUrlGenerator().getActionUrlForCalculateField(calculatedField.getId(), className, calculatedField.getFldCompleteNameInQuery());
			
			nodeCounter++;
			tree.addNode("" + nodeCounter, "" + parentEntityNodeId, 
					calculatedField.getFldLabel(),
					fieldAction,  
					calculatedField.getFldLabel(),
					"_self",
					getUrlGenerator().getResourceUrl("../img/cfield.gif"),
					getUrlGenerator().getResourceUrl("../img/cfield.gif"),
					"", "", "",  "", "");
		}
			
		return nodeCounter;
	}
	
	public int addSubEntitiesNodes(IQbeTree tree,
								   String className,
								   int parentEntityNodeId, int nodeCounter,
								   int recursionLevel, List subEntities) {
		
		// ordinare qui
		QbeTreeRelations fields = new QbeTreeRelations();
		fields.addAllRelations( subEntities );
		List sortedList = fields.getFieldsOrderedByLabel();
		
		
		Iterator associatedClassIterator = sortedList.iterator();
		while (associatedClassIterator.hasNext()){
			RelationField aRelationField = (RelationField)associatedClassIterator.next();
			
			if (aRelationField.getClassName().equalsIgnoreCase(className) || recursionLevel > 3) {
				/* stop recursion */
			} else {
				nodeCounter = addEntityNode(tree, aRelationField.getClassName(),
						aRelationField.getRelationOnColumnName(), parentEntityNodeId, nodeCounter, 
						aRelationField.getFieldName(),  recursionLevel+1);
			}
		}
		
		return nodeCounter;
	}
	
	

	

	public String getModality() {
		return modality;
	}

	public void setModality(String modality) {
		this.modality = modality;
	}

	private class QbeTreeFields {

		private List list;
		
		QbeTreeFields() {
			list = new ArrayList();
		}
		
		void addField(String hibernateClassName) {
			String label = 
				JsTreeUtils.getLabelForClass(datamartModel, hibernateClassName);
			QbeTreeField field = new QbeTreeField(label, hibernateClassName);
			list.add(field);
		}
		
		void addAllFields(Set hibernateClassNames) {
			if (hibernateClassNames != null && hibernateClassNames.size() > 0) {
				Iterator it = hibernateClassNames.iterator();
				while (it.hasNext()) {
					String hibernateClassName = (String) it.next();
					addField(hibernateClassName);
				}
			}
		}
		
		void addAllFields(List hibernateClassNames) {
			if (hibernateClassNames != null && hibernateClassNames.size() > 0) {
				Iterator it = hibernateClassNames.iterator();
				while (it.hasNext()) {
					String hibernateClassName = (String) it.next();
					addField(hibernateClassName);
				}
			}
		}
		
		List getFieldsOrderedByLabel () {
			Collections.sort(list);
			List toReturn = new ArrayList();
			Iterator it = list.iterator();
			while (it.hasNext()) {
				QbeTreeField field = (QbeTreeField) it.next();
				toReturn.add(field.getHibernateClassName());
			}
			return toReturn;
		}
		
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	private class QbeTreeField implements Comparable {
		
		private String hibernateClassName;
		private String label;
		
		QbeTreeField (String label, String hibernateClassName) {
			this.hibernateClassName = hibernateClassName;
			this.label = label;
		}
		
		public int compareTo(Object o) {
			if (o == null) throw new NullPointerException();
			if (!(o instanceof QbeTreeField)) throw new ClassCastException();
			QbeTreeField anotherField = (QbeTreeField) o;
			return this.getLabel().compareTo(anotherField.getLabel());
		}
		
		public String getHibernateClassName() {
			return hibernateClassName;
		}
		public void setHibernateClassName(String hibernateClassName) {
			this.hibernateClassName = hibernateClassName;
		}
		public String getLabel() {
			return label;
		}
		public void setLabel(String label) {
			this.label = label;
		}
		
	}
	
	private class QbeTreeRelations {

		private List list;
		
		QbeTreeRelations() {
			list = new ArrayList();
		}
		
		void addRelation(RelationField relationField) {
			String label = null;
			String classLabel = JsTreeUtils.getLabelForClass(datamartModel, relationField.getClassName());
			String labelForRelation =
				JsTreeUtils.getLabelForForeignKey(datamartModel, relationField.getClassName() + "(" + relationField.getRelationOnColumnName() + ")");
			if (labelForRelation != null){
				label = labelForRelation;
			} else {
				label = classLabel + "(" + relationField.getRelationOnColumnName() + ")";
			}
			QbeTreeRelation field = new QbeTreeRelation(label, relationField);
			list.add(field);
		}
		
		void addAllRelations(Set relations) {
			if (relations != null && relations.size() > 0) {
				Iterator it = relations.iterator();
				while (it.hasNext()) {
					RelationField relation = (RelationField) it.next();
					addRelation(relation);
				}
			}
		}
		
		void addAllRelations(List relations) {
			if (relations != null && relations.size() > 0) {
				Iterator it = relations.iterator();
				while (it.hasNext()) {
					RelationField relation = (RelationField) it.next();
					addRelation(relation);
				}
			}
		}
		
		List getFieldsOrderedByLabel () {
			Collections.sort(list);
			List toReturn = new ArrayList();
			Iterator it = list.iterator();
			while (it.hasNext()) {
				QbeTreeRelation field = (QbeTreeRelation) it.next();
				toReturn.add(field.getRelationField());
			}
			return toReturn;
		}
		
	}
	
	
	private class QbeTreeRelation implements Comparable {
		
		private RelationField relationField;
		private String label;
		
		QbeTreeRelation (String label, RelationField relationField) {
			this.relationField = relationField;
			this.label = label;
		}
		
		public int compareTo(Object o) {
			if (o == null) throw new NullPointerException();
			if (!(o instanceof QbeTreeRelation)) throw new ClassCastException();
			QbeTreeRelation anotherField = (QbeTreeRelation) o;
			return this.getLabel().compareTo(anotherField.getLabel());
		}
		
		public RelationField getRelationField() {
			return relationField;
		}
		public void setRelationField(RelationField relationField) {
			this.relationField = relationField;
		}
		public String getLabel() {
			return label;
		}
		public void setLabel(String label) {
			this.label = label;
		}
		
	}
	
	
	
	
	
	
	/*
	
	protected Collection getSelectedClassNames() {
		Set selectedClassNames = null;
				
		selectedClassNames = new HashSet();
		EntityClass ec = null;	
		Collection allClassNames = getClassNames();		
		for (Iterator it = dataMartWizard.getQuery().getEntityClassesItertor(); it.hasNext(); ){
				ec  = (EntityClass)it.next();	
				if(allClassNames.contains(ec.getClassName())) {
					selectedClassNames.add(ec.getClassName());
				}
		}
				
		return selectedClassNames;	 
	}
	*/

	protected IDataMartModel getDatamartModel() {
		return datamartModel;
	}

	protected void setDatamartModel(IDataMartModel datamartModel) {
		this.datamartModel = datamartModel;
	}

	public String getClassPrefix() {
		return classPrefix;
	}

	public void setClassPrefix(String classPrefix) {
		this.classPrefix = classPrefix;
	}


	public IQbeTreeUrlGenerator getUrlGenerator() {
		return urlGenerator;
	}


	public void setUrlGenerator(IQbeTreeUrlGenerator urlGenerator) {
		this.urlGenerator = urlGenerator;
	}


	protected Class getQbeTreeClass() {
		return qbeTreeClass;
	}


	protected void setQbeTreeClass(Class qbeTreeClass) {
		this.qbeTreeClass = qbeTreeClass;
	}
}
